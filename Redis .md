# Redis 
> 林创彬 2017 9-6

## 介绍
> Redis是一个开源的，高性能，基于键值对的缓存与存储系统，提供多种键值数据类型来适应不同场景下的缓存与存储需求。同时Redis的诸多高层级功能使其可以胜任消息队列，任务队列等不同角色。   


简单分析讨论redis和memcached的优劣。性能上redis是单线程模型，memcached是支持多线程，在多核服务器上后者的性能理论上相对高一些。但是redis的性能已经足够应付大部分场景，大部分场合上性能不会成为瓶颈，随着redis3.0的推出，memcached几乎所有功能都称为了redis的子集，redis也增加了对集群的支持。


> 目前为止redis支持的键值类型如下：  
 
 ```
  1.字符串类型  
  2.散列类型  
  3.列表类型  
  4.集合类型  
  5.有序集合类型
 ```
今天的分享会主要以介绍这5种类型的设计使用与跟mysql设计中的区别。

### 字符串  
> 字符串类型是redis最基本的数据类型，它能存储*任何形式*的字符串，包括,json化的对象。二进制数据。可以存储用户的邮箱，甚至可以存储json后的对象甚至是一张腿片，最大的容量是512M.  
>  字符串类型是其他4种数据类型的基础，其他类型和字符串类型实际上是组织字符串的形式不同。
> 简单的命令  

```
set key value（设置值）  
get key(获取值)
incr key（递增）
```
#### 例子
> 实现一个文章访问量  


```
有这样一个博客，博客的一个常用功能是统计文章的访问量。  
我们可以为每篇文章使用一个名为post:文章ID:page.view的键来记录文章的访问量，  
每次访问文章就可以使用incr命令让相应的键值递增。

生成自增ID。在mysql中设置一个字段为主键，并设置auto_increment属性。  
在redis中，对每一类对象使用为 对象(负数形式):count 的键来存储  
当前类型对象的数量，每新增一个新对象，就使用incr递增该键的值。
如 incr books:count
```

> redis 对于键的命名的并没有强制的要求，但比较好实践是用“对象类型:对象ID:对象属性“来命名一个键，如使用键 user:1:friends来存储Id为1的用户的用户列表，对于多个单词则推荐使用“.”分割。  

### 散列类型  
> 散列类型是一种字典结构，存储了字段和字段值的映射，字段值只能是字符串，不能是其他类型，也就是说散列类型不能够嵌套其他的数据结构。散列类型适合存储对象。    

#### 例子
使用对象类型和ID构成键名，使用字段表示对象的属性，而字段值则存储属性值。如图一。  
回想在关系型数据库里要存储文章的对象。  

```sql
CREATE TABLE IF NOT EXISTS `post` (
  `id` int(11) NOT NULL AUTO_INCREMENT COMMENT '主键',
  `name` varchar(30) DEFAULT '' COMMENT '名称',
  `type` varchar(30) DEFAULT '' COMMENT '类别',
  `des` varchar(30) DEFAULT '' COMMENT '描述',
  `time` int NULL COMMENT '发表时间',
 PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=1 DEFAULT CHARSET=utf8 COMMENT='文章';

```  

假设我们需要为某些文章数据增加一个出处，在mysql中我们无法单独为某条记录增加属性，需要把修改表结构增加一个字段from。对于其他数据来说，这个字段是冗余的，当不同的记录需要不同的属性时，表的字段数量回越来越多，难以维护。  
redis的散列类型不存在着以上问题，我们在（图一）描述图书对象的存储结构，这种结构是人为的约定，redis不要求每个键都依据这个结构存储，可以完全自由地为增减字段而不影响其他键。  

```
hset key field value  (赋值)
hget key field （取值）
```

### 列表类型  
> 可以存储一个有序的字符串列表，常用的操作是向列表的两端添加元素或者获得列表的某一片段，内部是实现双向链表实现的，获取越接近两段的数据的元素速度就越快。不过列表的代价是通过索引访问元素比较慢，比如是要找到列表中有1000+个元素，要找到第333位元素，查找的效率会相对比较慢。  
> 
> 如上的特性能快速完成mysql中难以应付的场景，比如社交网站的新鲜事，我们关心的是最新的内容，使用列表类型存储，即使新鲜事的总数达到几千万个，获取最新的100条数据也是极快的。  

```
想列表两端添加元素
lpush key value
rpush key value
获取列表片段
lrange key start stop
```
#### 例子
使用列表类型实现分页，使用类型类型键 posts:list 记录文章ID，当发布新文章的时候使用lpush把新文章的ID加入这个列表中。有了文章列表ID，就可以随意的使用lrange命令来实现文章的分页显示了（图二）。

疑问：使用列表类型键存储文章ID列表，有以下的问题：  
1.发布时间不能修改，修改文章的发布时间不久要修改post:文章ID中的time字段，还需按照时间发布时间重新排列post:list中的元素，繁琐。
2.当文章数过多，访问中间的数据性能较差。

### 集合类型
> 集合和列表有很多相似之处。集合中每个元素都是不同，常用的操作是向集合中加入或者删除元素，判断元素是否存在，最方便的是集合类型键之间还可以进行交集，并集，差集运算。

```
增加删除元素  
sadd key member [member ...]
srem ket member
获取集合的元素
smembers key
集合等运算
并集，交集 ...
SINTER key1 key2 
``` 
#### 例子
在mysql中有三张表。posts,tags,posts_tags,分别表示文章数据，标签，文章与标签的对应关系，结构不多书，就是多对多的关系。假设要查询某个标签下的所有文章，可以想象出sql十分复杂，需要关联。。  

```sql
CREATE TABLE `posts_tags ` (
  `post_id` int(11) DEFAULT NULL,
  `tag_id` int(11) DEFAULT NULL
) ENGINE=InnoDB DEFAULT CHARSET=utf8
```
在redis下，为每一个标签使用一个名为 tag:标签名称:post的集合类型键值存储标有该标签的文章ID 列表。可以轻松使用交集的命令找到某标签下所有文章，甚至是共同拥有几个标签的文章（图三）。

### 有序集合类型
如果想要增加按照文章的访问量排序
> 比上一节介绍的集合类型的区别就是‘有序’两个字。在集合类型的基础上有序集合类型中的每个元素都关联一个分数，这让我们不仅完成插入，删除等集合类型支持的操作，还能够获得分数最高和最低的前n个元素。  
> 有序集合跟列表有些相似。  

```
1.二者都是有序的，  
2.二者都可以获得某一范围的元素
```
区别  

```
1.列表类型靠近两端的数据极快，当元素增多，访问中间数据的速度会较慢。  
2.有序集合读取中间部分的数据很快。  
3.列表不能简单调整某个元素的位置，但是有序集合可以。
4.有序集合更耗费内存。
```

```
命令
zadd key score member [score member...]
比如记录三位运动员的评分
zadd scored Ben 87 Tom 88 Peter 77
获取排名在某个范围的元素列表
zrange key start stop
```
(图四)
####  例子
要按照文章的点击排序，就必须再额外使用一个有序集合的键来实现。在这个键中比文章的ID作为元素，以该文章的点击量作为该元素的分数，每次用户访问一篇文章的使用就通过zincrby命令更新访问量。  

## 进阶

### 场景 
> 在实际开发中，经常会遇到有实效的数据，比如限时优惠的活动，缓存或者验证码等，过了一定时间就需要删除这些数据。  
> 在关系型数据中一半需要额外的字段记录到期时间，然后定期检验删除过期的数据。  
> 在redis中，可以使用*expire*命令设置一个键的过期时间，

```
expire key number
```

#### 实现访问频率限制
> 有时候为了减轻服务器的压力，需要限制每个用户一段时间的最大访问量。比如限制一个用户一分钟内只能访问100次接口。在mysql中怎么设计？  
> 在redis中可以这样设计
 

对每个用户使用一个名为rate.limit:用户id 的字符串类型键，每次用户访问就用incr命令递增该值，如果递增后的值是1，那么设置该键的过期时间为1分钟，每次用户访问接口时，就读取该键值，如果超过100就访问超过了限制，需要稍后再访问。每分钟后会自动删除，下一分钟又会重新计算。

> 问题：
假如有一个用户一分钟的第一秒访问了一次接口，同一分钟的最后一秒访问了50次，又在下一分钟的第一秒访问了51次，这样的访问时可以通过上面的访问频率限制的。但是实际上在2秒内访问了101次接口，这样和限制每个用户每分钟只能访问100次的限制差距较大。
  
如果要精确的控制用户的每分钟只能访问100次，可以使用一个列表类型的键来记录他最近100次访问博客的时间，一旦键中的元素超过了100个，就判断最早的时间距现在的时间是否小于1分钟（如图）。  

### php的使用

```php
<!--第一步，链接redis数据库-->
$redis = new Redis();
$redis->connect('127.0.0.1', 6379);
<!--先插入一个元素item到set-key集合-->
$redis->sadd('set-key','item'); 
```